
options
{
    LOOKAHEAD=1;
}

PARSER_BEGIN(Project)

import java.util.regex.*;
import java.util.ArrayList;

public class Project
{
    public static ArrayList<ParseException> errors;
    public static void main(String args[]) throws ParseException {
        Project myCalc = new Project(System.in);
        myCalc.errors = new ArrayList<ParseException>();
        try {
            SimpleNode root = myCalc.Program(); // devolve referência para o nó raizda árvore
            if(myCalc.errors.size() != 0) {
                for(int i = 0; i < myCalc.errors.size(); i++){
                    System.out.println("Unexpected symbol \"" + myCalc.errors.get(i).currentToken.image + "\" occurred in" 
                        + " Line:" + myCalc.errors.get(i).currentToken.beginLine 
                        + ", Column:" + myCalc.errors.get(i).currentToken.beginColumn);
                }
            } else 
                root.dump("");// imprime no ecrã a árvore
        } catch (ParseException e) {
            System.out.println("Unhandled Exception at line " + e.currentToken.beginLine + " and column " + e.currentToken.beginColumn);
            System.out.println("\n\n" + e);
        }
        
       
    }
}

PARSER_END(Project)

SKIP :
{
    " " | "\r" | "\t" | "\n"
}

TOKEN :
{
    < THIS: "this" >
    | < NEW: "new" >
    | < FALSE: "false" >
    | < TRUE: "true" >
    | < LENGTH: "length" >
    | < COMA : "," >
    | < DOT : "." >
    | < SEMICOLON : ";" >
    | < NOT : "!" >
    | < MULT : "*" >
    | < DIV : "/" >
    | < SUB : "-" >
    | < ADD : "+" >
    | < MINOR : "<" >
    | < AND : "&&" >
    | < EQUAL : "=" >
    | < WHILE : "while" >
    | < IF : "if" >
    | < ELSE : "else" >
    | < OPENSQBRACK : "[" >
    | < CLOSESQBRACK : "]" >
    | < OPENPAR : "(" >
    | < CLOSEPAR : ")" >
    | < OPENBRACK : "{" >
    | < CLOSEBRACK : "}" >
    | < INT : "int" >
    | < BOOLEAN : "boolean" >
    | < STRING : "String">
    | < VOID : "void" >
    | < MAIN : "main" >
    | < RETURN : "return" >
    | < PUBLIC : "public" >
    | < STATIC : "static" >
    | < CLASS : "class" >
    | < EXTENDS : "extends" >
    | < OCTAL: "0"(["0"-"7"])+ >
    | < BINARY: "0b"("1"|"0")+ >
    | < HEX: "0"("x"|"X")(["0"-"9","a"-"f","A"-"F"])+ >
    | < DECIMAL: (["0"-"9"])+(("_")*(["0"-"9"])+)* >
    | < IDENTIFIER: ["a"-"z","A"-"Z"](["a"-"z","A"-"Z","0"-"9","_"])* >
}

void Empty() : {}
{
     {}
} 

void IntegerLiteral(): {}
{
    <OCTAL>
    | <BINARY>
    | <HEX>
    | <DECIMAL>
    | <SUB> <DECIMAL>
}

SimpleNode Program(): {}
{
    ClassDeclaration() /*<LF>*/  { return jjtThis; }// código Java entre chavetas
}

void ClassDeclaration(): {} 
{
    <CLASS> <IDENTIFIER> [<EXTENDS> <IDENTIFIER>] <OPENBRACK> (VarDeclaration())* MainMethodDeclaration() <CLOSEBRACK>
}

void VarDeclaration():{}
{
    Type() <IDENTIFIER> <SEMICOLON>
}

//pode haver mais que uma MainDeclaration() uma forma de resolver seria logo a seguir
//ao <OPENBRACK> fazer isto [<PUBLIC> MainDeclaration()] e ter uma funcao inClass()
//que o que fazia era {VarDeclaration() | Statement()} 
void MainMethodDeclaration():{}
{
    (<PUBLIC> (MainDeclaration() | MethodDeclaration()))* 
}

void MainDeclaration():{} 
{
    <STATIC> <VOID> <MAIN> <OPENPAR> <STRING> <OPENSQBRACK> <CLOSESQBRACK> <IDENTIFIER> <CLOSEPAR> <OPENBRACK> (InMethod())* <CLOSEBRACK> 
}

void MethodDeclaration():{} 
{
    Type() <IDENTIFIER> <OPENPAR> [Type() <IDENTIFIER> (<COMA> Type() <IDENTIFIER>)*] <CLOSEPAR> <OPENBRACK> (InMethod())* <RETURN> Expression() <SEMICOLON> <CLOSEBRACK>
}

void Type():{}
{
    <INT> TypeAux()
    | <BOOLEAN>
    | <IDENTIFIER>
}

void TypeAux():{}
{
    [<OPENSQBRACK> <CLOSESQBRACK>]
}

void InMethod():{} 
{
    VarDeclarationWoIdent()
    | Statement()
}

void Statement():{} 
{
    <OPENBRACK> (Statement())* <CLOSEBRACK>
    | <IF> <OPENPAR> Expression() <CLOSEPAR> Statement() <ELSE> Statement()
    
    /*BEGINNING OF WHILE STATEMENT*/

    | <WHILE> <OPENPAR> 
    try {
        Expression() <CLOSEPAR>  // se der para voltar atrás num token, põe-se fora do try o <CLOSEPAR> e no do while
                                 // podemos pôr dentro do if todos os tokens que podem vir a seguir ao while (tipo a chaveta e isso)
    }
    catch(ParseException e) {
        errors.add(e);
        Token t;
        do {
            t = getNextToken();
        } while (t.kind != CLOSEPAR);
    }
     Statement()

    /*END OF WHILE STATEMENT*/

    | ExpressionWoIdent() <SEMICOLON> //criar Expression2 com ExpressionToken2 de maneira a nao usar IDENTIFIER
    | <IDENTIFIER> StatementAux2()
}


void StatementAux():{}
{
    [ <OPENSQBRACK> Expression() <CLOSESQBRACK> ] 
}

void StatementAux2():{}
{
    [StatementAux() <EQUAL> Expression()] <SEMICOLON> |
    <IDENTIFIER> <SEMICOLON> //para que serve esta linha?
    
    //ALTEREI AQUI!!
    | <DOT> ExpressionAuxDot() <SEMICOLON>
}


void ExpressionWoIdent():{}
{
    ExpressionTokenWoIdent() ExpressionAux()
}


void ExpressionTokenWoIdent():{}
{
    <TRUE>
    | <FALSE>
    | <THIS>
    | <NEW> ExpressionNew()
    | <NOT> Expression()
    | <OPENPAR> Expression() <CLOSEPAR>
    | IntegerLiteral()
}

void VarDeclarationWoIdent():{}
{
    TypeWoIdent() <IDENTIFIER> <SEMICOLON>
}

void TypeWoIdent():{}
{
    <INT> TypeAux()
    | <BOOLEAN>
}

void Expression():{}
{
    ExpressionMinor() ExpressionAnd()
}

void ExpressionAnd():{} {
    <AND> ExpressionMinor() ExpressionAnd()
    | Empty()
}

void ExpressionMinor():{} {
    ExpressionAdd() ExpressionMinorAux()
}

void ExpressionMinorAux():{} {
    <MINOR> ExpressionAdd() ExpressionMinorAux() 
    | Empty()
}

void ExpressionAdd():{} {
    ExpressionMult() ExpressionAddAux()
}

void ExpressionAddAux():{} {
    (<ADD> | <SUB>) ExpressionMult() ExpressionAddAux() 
    | Empty()
}

void ExpressionMult():{} {
    ExpressionRestOfClauses() ExpressionMultAux()
}

void ExpressionMultAux():{} {
    (<MULT> | <DIV>) ExpressionRestOfClauses() ExpressionMultAux() 
    | Empty()
}

void ExpressionRestOfClauses():{} {
    ExpressionToken() ExpressionAux()
}

void ExpressionAux():{}
{
    //(<SUB> | <AND> | <MINOR> | <ADD> | <MULT> | <DIV>) Expression() ExpressionAux()
    <DOT> ExpressionAuxDot()
    | <OPENSQBRACK> Expression() <CLOSESQBRACK> ExpressionAux()
    | Empty()
}

void ExpressionAuxDot():{}
{
    <LENGTH> ExpressionAux()
    | <IDENTIFIER> <OPENPAR> [Expression() (<COMA> Expression())*] <CLOSEPAR>

}

void ExpressionToken():{}
{
    <TRUE>
    | <FALSE>
    | <THIS>
    | <NEW> ExpressionNew()
    | <NOT> Expression()
    | <OPENPAR> Expression() <CLOSEPAR>
    | <IDENTIFIER>
    | IntegerLiteral()
}

void ExpressionNew():{}
{
    <INT> <OPENSQBRACK> Expression() <CLOSESQBRACK>
    | <IDENTIFIER> <OPENPAR> <CLOSEPAR> 
}

